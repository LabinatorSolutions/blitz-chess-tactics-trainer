<% content_for(:title) { "Puzzle Themes" } %>

<div class="about container">
  <h3 class="question">Puzzle Themes</h3>
  <p class="answer">
    Chess tactics are short-term sequences of moves that result in a concrete advantage. 
    Understanding different tactical patterns is essential for improving your chess game. 
    Here are the most common puzzle themes you'll encounter in our tactical puzzles:
  </p>

  <h3 class="question">Pins</h3>
  <p class="answer">
    A <strong>pin</strong> occurs when a piece cannot move without exposing a more valuable piece behind it to capture. 
    The pinned piece is "pinned" to the more valuable piece by an attacking piece.
    <br><br>
    <strong>Example:</strong> A bishop pins a knight to the king. The knight cannot move because it would expose the king to check.
    <br><br>
    <strong>Types of pins:</strong>
    <br>• <strong>Absolute pin:</strong> Pinned to the king (cannot move at all)
    <br>• <strong>Relative pin:</strong> Pinned to a more valuable piece (can move but would lose material)
  </p>
  
  <% if @theme_examples['pin'] %>
    <div class="theme-example">
      <h4>Example Pin Puzzle</h4>
      <div class="recent-puzzle-item" data-puzzle-id="<%= @theme_examples['pin'].puzzle_id %>">
        <div class="puzzle-miniboard">
          <%= linked_puzzle_miniboard(@theme_examples['pin']) %>
        </div>
        <div class="puzzle-info">
          <div class="puzzle-actions">
            <button class="show-solution-btn view-solution-btn" 
                    data-puzzle-id="<%= @theme_examples['pin'].puzzle_id %>"
                    data-initial-fen="<%= @theme_examples['pin'].initial_fen %>"
                    data-solution-lines="<%= @theme_examples['pin'].lines_tree.to_json %>">
              Show solution
            </button>
          </div>
        </div>
      </div>
    </div>
  <% end %>

  <h3 class="question">Skewers</h3>
  <p class="answer">
    A <strong>skewer</strong> is the opposite of a pin. A more valuable piece is attacked and forced to move, 
    exposing a less valuable piece behind it to capture.
    <br><br>
    <strong>Example:</strong> A rook attacks a queen, forcing it to move and exposing a rook behind it.
    <br><br>
    <strong>Key difference from pins:</strong> In a skewer, the more valuable piece is attacked first, 
    while in a pin, the less valuable piece is attacked.
  </p>
  
  <% if @theme_examples['skewer'] %>
    <div class="theme-example">
      <h4>Example Skewer Puzzle</h4>
      <div class="recent-puzzle-item" data-puzzle-id="<%= @theme_examples['skewer'].puzzle_id %>">
        <div class="puzzle-miniboard">
          <%= linked_puzzle_miniboard(@theme_examples['skewer']) %>
        </div>
        <div class="puzzle-info">
          <div class="puzzle-actions">
            <button class="show-solution-btn view-solution-btn" 
                    data-puzzle-id="<%= @theme_examples['skewer'].puzzle_id %>"
                    data-initial-fen="<%= @theme_examples['skewer'].initial_fen %>"
                    data-solution-lines="<%= @theme_examples['skewer'].lines_tree.to_json %>">
              Show solution
            </button>
          </div>
        </div>
      </div>
    </div>
  <% end %>

  <h3 class="question">Forks</h3>
  <p class="answer">
    A <strong>fork</strong> occurs when one piece attacks two or more enemy pieces simultaneously. 
    The opponent can only defend one of the attacked pieces, losing the other.
    <br><br>
    <strong>Example:</strong> A knight attacks both a queen and a rook at the same time.
    <br><br>
    <strong>Common forking pieces:</strong>
    <br>• <strong>Knights:</strong> Excellent for forking due to their unique movement
    <br>• <strong>Pawns:</strong> Can fork pieces diagonally
    <br>• <strong>Queens:</strong> Can fork multiple pieces in different directions
  </p>
  
  <% if @theme_examples['fork'] %>
    <div class="theme-example">
      <h4>Example Fork Puzzle</h4>
      <div class="recent-puzzle-item" data-puzzle-id="<%= @theme_examples['fork'].puzzle_id %>">
        <div class="puzzle-miniboard">
          <%= linked_puzzle_miniboard(@theme_examples['fork']) %>
        </div>
        <div class="puzzle-info">
          <div class="puzzle-actions">
            <button class="show-solution-btn view-solution-btn" 
                    data-puzzle-id="<%= @theme_examples['fork'].puzzle_id %>"
                    data-initial-fen="<%= @theme_examples['fork'].initial_fen %>"
                    data-solution-lines="<%= @theme_examples['fork'].lines_tree.to_json %>">
              Show solution
            </button>
          </div>
        </div>
      </div>
    </div>
  <% end %>

  <h3 class="question">Discovered Attacks</h3>
  <p class="answer">
    A <strong>discovered attack</strong> occurs when moving one piece reveals an attack by another piece behind it.
    <br><br>
    <strong>Example:</strong> Moving a knight reveals a bishop attacking the enemy queen.
    <br><br>
    <strong>Types of discovered attacks:</strong>
    <br>• <strong>Discovered check:</strong> The revealed attack gives check
    <br>• <strong>Discovered attack:</strong> The revealed attack threatens a piece (not check)
    <br>• <strong>Double check:</strong> Both the moving piece and the revealed piece give check
  </p>
  
  <% if @theme_examples['discoveredAttack'] %>
    <div class="theme-example">
      <h4>Example Discovered Attack Puzzle</h4>
      <div class="recent-puzzle-item" data-puzzle-id="<%= @theme_examples['discoveredAttack'].puzzle_id %>">
        <div class="puzzle-miniboard">
          <%= linked_puzzle_miniboard(@theme_examples['discoveredAttack']) %>
        </div>
        <div class="puzzle-info">
          <div class="puzzle-actions">
            <button class="show-solution-btn view-solution-btn" 
                    data-puzzle-id="<%= @theme_examples['discoveredAttack'].puzzle_id %>"
                    data-initial-fen="<%= @theme_examples['discoveredAttack'].initial_fen %>"
                    data-solution-lines="<%= @theme_examples['discoveredAttack'].lines_tree.to_json %>">
              Show solution
            </button>
          </div>
        </div>
      </div>
    </div>
  <% end %>

  <h3 class="question">Double Attacks</h3>
  <p class="answer">
    A <strong>double attack</strong> is when one move creates two simultaneous threats. 
    This is similar to a fork but can involve different types of threats.
    <br><br>
    <strong>Example:</strong> Moving a piece to attack an enemy piece while also creating a mating threat.
    <br><br>
    <strong>Common double attack patterns:</strong>
    <br>• Attacking a piece while giving check
    <br>• Attacking a piece while threatening mate
    <br>• Creating a tactical threat while defending your own piece
  </p>
  
  <% if @theme_examples['doubleAttack'] %>
    <div class="theme-example">
      <h4>Example Double Attack Puzzle</h4>
      <div class="recent-puzzle-item" data-puzzle-id="<%= @theme_examples['doubleAttack'].puzzle_id %>">
        <div class="puzzle-miniboard">
          <%= linked_puzzle_miniboard(@theme_examples['doubleAttack']) %>
        </div>
        <div class="puzzle-info">
          <div class="puzzle-actions">
            <button class="show-solution-btn view-solution-btn" 
                    data-puzzle-id="<%= @theme_examples['doubleAttack'].puzzle_id %>"
                    data-initial-fen="<%= @theme_examples['doubleAttack'].initial_fen %>"
                    data-solution-lines="<%= @theme_examples['doubleAttack'].lines_tree.to_json %>">
              Show solution
            </button>
          </div>
        </div>
      </div>
    </div>
  <% end %>

  <h3 class="question">Deflection</h3>
  <p class="answer">
    A <strong>deflection</strong> forces an enemy piece to move away from a key square or piece, 
    removing its protection or influence.
    <br><br>
    <strong>Example:</strong> Sacrificing a piece to force the enemy queen away from defending a key square.
    <br><br>
    <strong>Common deflection targets:</strong>
    <br>• Defenders of important squares
    <br>• Pieces protecting the king
    <br>• Pieces blocking tactical sequences
  </p>

  <h3 class="question">Decoy</h3>
  <p class="answer">
    A <strong>decoy</strong> lures an enemy piece to a disadvantageous square, 
    often to set up a tactical sequence.
    <br><br>
    <strong>Example:</strong> Offering a piece to lure the enemy king to a square where it can be checkmated.
    <br><br>
    <strong>Decoy vs Deflection:</strong>
    <br>• <strong>Decoy:</strong> Lures a piece TO a bad square
    <br>• <strong>Deflection:</strong> Forces a piece AWAY from a good square
  </p>

  <h3 class="question">Zwischenzug (In-Between Move)</h3>
  <p class="answer">
    A <strong>zwischenzug</strong> (German for "in-between move") is an unexpected move inserted 
    in an apparently forced sequence of moves.
    <br><br>
    <strong>Example:</strong> Instead of recapturing immediately, you first give check, 
    forcing the opponent to respond, then recapture with advantage.
    <br><br>
    <strong>Key principle:</strong> Look for moves that can be inserted into tactical sequences 
    to gain tempo or create additional threats.
  </p>

  <h3 class="question">Removing the Defender</h3>
  <p class="answer">
    <strong>Removing the defender</strong> involves capturing or driving away a piece 
    that is protecting another piece or square.
    <br><br>
    <strong>Example:</strong> Capturing a pawn that is defending a knight, 
    then capturing the now-undefended knight.
    <br><br>
    <strong>Common targets:</strong>
    <br>• Pieces defending other pieces
    <br>• Pieces defending key squares
    <br>• Pieces blocking tactical sequences
  </p>

  <h3 class="question">Overloading</h3>
  <p class="answer">
    <strong>Overloading</strong> occurs when a piece is given too many defensive responsibilities 
    and cannot fulfill all of them.
    <br><br>
    <strong>Example:</strong> A queen defending both a rook and a knight. 
    If you attack both pieces, the queen cannot defend both.
    <br><br>
    <strong>How to create overloads:</strong>
    <br>• Attack multiple pieces defended by the same piece
    <br>• Force a piece to defend while also requiring it to attack
    <br>• Create multiple threats that require the same defensive resource
  </p>

  <h3 class="question">Interference</h3>
  <p class="answer">
    <strong>Interference</strong> involves placing a piece between two enemy pieces 
    to disrupt their coordination or communication.
    <br><br>
    <strong>Example:</strong> Placing a piece between a rook and the square it needs to control, 
    breaking the connection.
    <br><br>
    <strong>Common interference targets:</strong>
    <br>• Rook and king connections
    <br>• Bishop and target square connections
    <br>• Queen and defended piece connections
  </p>

  <h3 class="question">Windmill</h3>
  <p class="answer">
    A <strong>windmill</strong> is a series of discovered checks and regular checks 
    that allows you to capture multiple pieces or gain significant material.
    <br><br>
    <strong>Example:</strong> A rook gives discovered check, then regular check, 
    then discovered check again, capturing pieces on each discovered check.
    <br><br>
    <strong>Key elements:</strong>
    <br>• Alternating discovered checks and regular checks
    <br>• Capturing material on each discovered check
    <br>• Forcing the king to move in a predictable pattern
  </p>

  <h3 class="question">X-Ray Attack</h3>
  <p class="answer">
    An <strong>X-ray attack</strong> occurs when a piece attacks through another piece, 
    as if it has X-ray vision.
    <br><br>
    <strong>Example:</strong> A rook attacks an enemy piece through a friendly piece, 
    or a bishop attacks the king through an enemy piece.
    <br><br>
    <strong>Common X-ray patterns:</strong>
    <br>• Rook attacking through friendly pieces
    <br>• Bishop attacking through enemy pieces
    <br>• Queen combining with other pieces for long-range attacks
  </p>

  <h3 class="question">Back Rank Mate</h3>
  <p class="answer">
    A <strong>back rank mate</strong> occurs when the king is trapped on the back rank 
    (first rank for White, eighth rank for Black) and is checkmated by a rook or queen.
    <br><br>
    <strong>Example:</strong> A rook on the back rank checkmates a king that is blocked 
    by its own pawns.
    <br><br>
    <strong>Key elements:</strong>
    <br>• King trapped on back rank by own pawns
    <br>• Rook or queen controlling the back rank
    <br>• No escape squares for the king
    <br>• Often involves sacrificing material to clear the back rank
  </p>

  <h3 class="question">Smothered Mate</h3>
  <p class="answer">
    A <strong>smothered mate</strong> is a checkmate delivered by a knight where the king 
    is surrounded (smothered) by its own pieces and cannot escape.
    <br><br>
    <strong>Example:</strong> A knight checkmates a king that is completely surrounded 
    by its own pieces, with no escape squares.
    <br><br>
    <strong>Common patterns:</strong>
    <br>• Knight delivers the checkmate
    <br>• King is blocked by its own pieces
    <br>• Often involves a queen sacrifice to set up the mate
    <br>• Requires precise calculation of the mating sequence
  </p>

  <h3 class="question">Battery</h3>
  <p class="answer">
    A <strong>battery</strong> is formed when two pieces of the same color are aligned 
    on the same rank, file, or diagonal, with the front piece able to move and reveal 
    the attack of the back piece.
    <br><br>
    <strong>Example:</strong> Two rooks on the same file, or a queen and bishop on the same diagonal.
    <br><br>
    <strong>Types of batteries:</strong>
    <br>• <strong>Rook battery:</strong> Two rooks on the same rank or file
    <br>• <strong>Queen-bishop battery:</strong> Queen and bishop on the same diagonal
    <br>• <strong>Queen-rook battery:</strong> Queen and rook on the same rank or file
    <br>• <strong>Bishop battery:</strong> Two bishops on the same diagonal
  </p>

  <h3 class="question">Clearance Sacrifice</h3>
  <p class="answer">
    A <strong>clearance sacrifice</strong> involves sacrificing a piece to clear a square 
    or line for another piece to use effectively.
    <br><br>
    <strong>Example:</strong> Sacrificing a knight to clear a diagonal for a bishop 
    to deliver checkmate.
    <br><br>
    <strong>Common clearance patterns:</strong>
    <br>• Clearing a square for a piece to occupy
    <br>• Clearing a line for a piece to attack along
    <br>• Removing a blocking piece to allow a tactical sequence
    <br>• Often involves sacrificing material for a greater gain
  </p>

  <h3 class="question">Attraction</h3>
  <p class="answer">
    <strong>Attraction</strong> is a tactical motif where you force an enemy piece 
    to move to a specific square, usually to set up a tactical sequence.
    <br><br>
    <strong>Example:</strong> Offering a piece to force the enemy king to a square 
    where it can be checkmated.
    <br><br>
    <strong>Attraction vs Decoy:</strong>
    <br>• <strong>Attraction:</strong> Forces a piece to a specific square for tactical purposes
    <br>• <strong>Decoy:</strong> Lures a piece to a bad square
    <br>• Both involve offering material to manipulate enemy piece placement
  </p>

  <h3 class="question">Blocking</h3>
  <p class="answer">
    <strong>Blocking</strong> involves placing a piece on a line to prevent an enemy piece 
    from reaching a key square or delivering a threat.
    <br><br>
    <strong>Example:</strong> Placing a piece between an enemy rook and a key square 
    to prevent the rook from controlling that square.
    <br><br>
    <strong>Common blocking scenarios:</strong>
    <br>• Blocking a rook's path to a key square
    <br>• Intercepting a bishop's diagonal attack
    <br>• Preventing a queen from reaching a critical square
    <br>• Often involves sacrificing material to prevent a greater loss
  </p>

  <h3 class="question">Trapping</h3>
  <p class="answer">
    <strong>Trapping</strong> occurs when you force an enemy piece to a position where 
    it cannot escape and will eventually be captured.
    <br><br>
    <strong>Example:</strong> Forcing a knight to a corner where it has no legal moves 
    and will be captured on the next move.
    <br><br>
    <strong>Common trapping patterns:</strong>
    <br>• Trapping a piece in the corner
    <br>• Forcing a piece to a square where it's surrounded
    <br>• Using multiple pieces to cut off escape routes
    <br>• Often involves patient maneuvering rather than immediate tactics
  </p>

  <h3 class="question">Desperado</h3>
  <p class="answer">
    A <strong>desperado</strong> is a piece that is doomed to be captured but can 
    "go down fighting" by capturing as much material as possible before being taken.
    <br><br>
    <strong>Example:</strong> A knight that is trapped but can capture a rook 
    before being captured itself.
    <br><br>
    <strong>Key principles:</strong>
    <br>• The piece is inevitably going to be captured
    <br>• Try to capture the most valuable piece possible
    <br>• Look for ways to create additional threats while being captured
    <br>• Sometimes the desperado can escape if the opponent doesn't capture it
  </p>

  <h3 class="question">Pawn Promotion Tactics</h3>
  <p class="answer">
    <strong>Pawn promotion tactics</strong> involve using the threat of pawn promotion 
    to create tactical opportunities or force concessions from the opponent.
    <br><br>
    <strong>Example:</strong> Advancing a pawn to create a promotion threat that 
    forces the opponent to abandon other pieces.
    <br><br>
    <strong>Common promotion tactics:</strong>
    <br>• Using promotion threats to deflect enemy pieces
    <br>• Creating passed pawns that require constant attention
    <br>• Sacrificing material to promote a pawn
    <br>• Using promotion threats to set up other tactical motifs
  </p>

  <h3 class="question">Knight Fork Patterns</h3>
  <p class="answer">
    <strong>Knight fork patterns</strong> are specific tactical sequences where a knight 
    attacks multiple pieces simultaneously, often involving sacrifices to set up the fork.
    <br><br>
    <strong>Example:</strong> Sacrificing a piece to force the enemy king to a square 
    where it can be forked by a knight along with another piece.
    <br><br>
    <strong>Common knight fork setups:</strong>
    <br>• Forking king and queen
    <br>• Forking king and rook
    <br>• Forking two rooks
    <br>• Forking king and a key defensive piece
  </p>

  <h3 class="question">Rook Lifts</h3>
  <p class="answer">
    A <strong>rook lift</strong> involves moving a rook from the back rank to a more 
    active position, often to create tactical threats or support an attack.
    <br><br>
    <strong>Example:</strong> Moving a rook from the first rank to the third rank 
    to support a pawn advance or create a tactical threat.
    <br><br>
    <strong>Common rook lift patterns:</strong>
    <br>• Lifting rooks to support pawn storms
    <br>• Moving rooks to create tactical threats
    <br>• Using rook lifts to defend against enemy attacks
    <br>• Lifting rooks to participate in endgame tactics
  </p>

  <h3 class="question">Practice Makes Perfect</h3>
  <p class="answer">
    The best way to improve your tactical vision is through regular practice. 
    Try solving puzzles that focus on specific tactical patterns:
    <br><br>
    <a href="/infinity">Infinity Mode</a> - Endless tactical puzzles
    <br>
    <a href="/speedrun">Speedrun Mode</a> - Solve puzzles as fast as you can
    <br>
    <a href="/repetition">Repetition Mode</a> - Master patterns through repetition
    <br>
    <a href="/haste">Haste Mode</a> - Tactical puzzles with time pressure
    <br><br>
    Remember: Tactical patterns often combine with each other. 
    Look for multiple tactical motifs in the same position!
  </p>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // Handle "Show solution" buttons
  document.addEventListener('click', function(e) {
    if (e.target && e.target.classList.contains('view-solution-btn')) {
      e.preventDefault();
      playSolutionInMiniboard(e.target);
    }
  });
  
  function playSolutionInMiniboard(button) {
    const puzzleId = button.getAttribute('data-puzzle-id');
    const initialFen = button.getAttribute('data-initial-fen');
    const solutionLinesJson = button.getAttribute('data-solution-lines');
    
    if (!puzzleId || !initialFen || !solutionLinesJson) {
      console.error('Missing puzzle data for solution playback');
      return;
    }
    
    // Change button state
    const originalText = button.textContent;
    button.textContent = 'Showing solution...';
    button.style.opacity = '0.5';
    button.disabled = true;
    
    try {
      // Parse solution lines
      const solutionLines = JSON.parse(solutionLinesJson);
      const solutionMoves = extractSolutionMoves(solutionLines);
      
      if (solutionMoves.length === 0) {
        console.warn('No solution moves found');
        resetButton(button, originalText);
        return;
      }
      
      // Find the miniboard
      const puzzleItem = button.closest('.recent-puzzle-item');
      const miniboard = puzzleItem?.querySelector('.mini-chessboard');
      
      if (!miniboard) {
        console.error('Could not find miniboard for puzzle');
        resetButton(button, originalText);
        return;
      }
      
      // Play the solution
      playMovesInMiniboard(miniboard, solutionMoves, function() {
        resetButton(button, originalText);
      });
      
    } catch (error) {
      console.error('Error playing solution:', error);
      resetButton(button, originalText);
    }
  }
  
  function extractSolutionMoves(lines) {
    const moves = [];
    
    function traverse(node) {
      if (typeof node === 'string') {
        return; // Reached a terminal node
      }
      
      for (const [move, child] of Object.entries(node)) {
        if (child === 'win') {
          moves.push(move);
          return;
        } else if (typeof child === 'object') {
          moves.push(move);
          traverse(child);
          return;
        }
      }
    }
    
    traverse(lines);
    return moves;
  }
  
  function playMovesInMiniboard(miniboard, moves, onComplete) {
    if (moves.length === 0) {
      onComplete();
      return;
    }
    
    // Store original position if not already stored
    if (!miniboard.hasAttribute('data-original-stored')) {
      storeOriginalPosition(miniboard);
      miniboard.setAttribute('data-original-stored', 'true');
    }
    
    // Reset board to original position
    resetToOriginalPosition(miniboard);
    
    let currentMoveIndex = 0;
    
    // Clear any existing highlights
    clearHighlights(miniboard);
    
    function playNextMove() {
      if (currentMoveIndex < moves.length) {
        const moveUci = moves[currentMoveIndex];
        highlightMove(miniboard, moveUci);
        currentMoveIndex++;
        
        setTimeout(playNextMove, 700); // 0.7 second delay between moves
      } else {
        // Solution complete
        setTimeout(function() {
          clearHighlights(miniboard);
          onComplete();
        }, 1000);
      }
    }
    
    // Start playing moves
    setTimeout(playNextMove, 200);
  }
  
  function storeOriginalPosition(miniboard) {
    const squares = miniboard.querySelectorAll('.square');
    const originalPosition = [];
    
    squares.forEach((square, index) => {
      const piece = square.querySelector('.piece');
      if (piece) {
        originalPosition.push({
          squareIndex: index,
          pieceHtml: piece.outerHTML
        });
      }
    });
    
    // Store in a data attribute or global variable
    miniboard.originalPosition = originalPosition;
  }
  
  function resetToOriginalPosition(miniboard) {
    if (!miniboard.originalPosition) return;
    
    // Clear all current pieces
    const squares = miniboard.querySelectorAll('.square');
    squares.forEach(square => {
      const pieces = square.querySelectorAll('.piece');
      pieces.forEach(piece => piece.remove());
    });
    
    // Restore original pieces
    miniboard.originalPosition.forEach(({ squareIndex, pieceHtml }) => {
      if (squareIndex >= 0 && squareIndex < squares.length) {
        squares[squareIndex].insertAdjacentHTML('beforeend', pieceHtml);
      }
    });
    
    // Restore initial move highlighting if it exists
    const initialMove = miniboard.getAttribute('data-initial-move');
    if (initialMove) {
      setTimeout(() => {
        restoreInitialMoveHighlighting(miniboard, initialMove);
      }, 50);
    }
  }
  
  function restoreInitialMoveHighlighting(miniboard, moveUci) {
    if (moveUci.length < 4) return;
    
    const fromSquare = moveUci.substring(0, 2);
    const toSquare = moveUci.substring(2, 4);
    
    const squares = miniboard.querySelectorAll('.square');
    const fromSquareEl = getSquareByPosition(squares, fromSquare, miniboard);
    const toSquareEl = getSquareByPosition(squares, toSquare, miniboard);
    
    if (fromSquareEl) fromSquareEl.classList.add('move-from');
    if (toSquareEl) toSquareEl.classList.add('move-to');
  }
  
  function highlightMove(miniboard, moveUci) {
    if (moveUci.length < 4) return;
    
    const fromSquare = moveUci.substring(0, 2);
    const toSquare = moveUci.substring(2, 4);
    
    // Clear previous highlights
    clearHighlights(miniboard);
    
    // Find squares by position
    const squares = miniboard.querySelectorAll('.square');
    const fromSquareEl = getSquareByPosition(squares, fromSquare, miniboard);
    const toSquareEl = getSquareByPosition(squares, toSquare, miniboard);
    
    if (fromSquareEl && toSquareEl) {
      // Highlight squares
      fromSquareEl.classList.add('move-from');
      toSquareEl.classList.add('move-to');
      
      // Move the piece
      movePiece(fromSquareEl, toSquareEl);
    }
  }
  
  function movePiece(fromSquareEl, toSquareEl) {
    // Get the piece from the 'from' square
    const pieceEl = fromSquareEl.querySelector('.piece');
    if (!pieceEl) {
      // No piece to move, just highlight
      return;
    }
    
    // Clone the piece element
    const pieceClone = pieceEl.cloneNode(true);
    
    // Remove the piece from the source square
    pieceEl.remove();
    
    // Remove any existing piece from the destination square (capture)
    const existingPiece = toSquareEl.querySelector('.piece');
    if (existingPiece) {
      existingPiece.remove();
    }
    
    // Add the piece to the destination square
    toSquareEl.appendChild(pieceClone);
  }
  
  function clearHighlights(miniboard) {
    const highlightedSquares = miniboard.querySelectorAll('.square.move-from, .square.move-to');
    highlightedSquares.forEach(square => {
      square.classList.remove('move-from', 'move-to');
    });
  }
  
  function getSquareByPosition(squares, squareId, miniboard) {
    // Check if board is flipped
    const isFlipped = miniboard.getAttribute('data-flip') === 'true';
    
    // Convert square notation (e.g., "e4") to board index
    const file = squareId.charAt(0); // 'a' to 'h'
    const rank = parseInt(squareId.charAt(1)); // 1 to 8
    
    // Convert to 0-based indices
    let fileIndex = file.charCodeAt(0) - 'a'.charCodeAt(0); // 0 to 7
    let rankIndex = 8 - rank; // 0 to 7 (rank 8 = index 0, rank 1 = index 7)
    
    // If the board is flipped, reverse both file and rank indices
    if (isFlipped) {
      fileIndex = 7 - fileIndex; // Flip horizontally
      rankIndex = 7 - rankIndex; // Flip vertically
    }
    
    // Calculate the index in the squares array
    const squareIndex = rankIndex * 8 + fileIndex;
    
    return squares[squareIndex] || null;
  }
  
  function resetButton(button, originalText) {
    button.textContent = originalText;
    button.style.opacity = '1';
    button.disabled = false;
  }
});
</script>

<style>
.theme-example {
  margin: 20px 0;
  padding: 15px;
  border: 1px solid #444;
  border-radius: 8px;
  background-color: #2a2a2a;
}

.theme-example h4 {
  margin-top: 0;
  color: #fff;
}

.recent-puzzle-item {
  display: flex;
  align-items: center;
  gap: 20px;
  margin-top: 10px;
}

.puzzle-miniboard {
  flex-shrink: 0;
}

.puzzle-info {
  flex-grow: 1;
}

.puzzle-actions {
  margin-top: 10px;
}

.show-solution-btn {
  background: rgba(27, 73, 171, 0.8);
  color: white;
  border: none;
  padding: 6px 12px;
  border-radius: 4px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease, opacity 0.3s ease;
  opacity: 1;
  min-width: 120px;
  text-align: center;
}

.show-solution-btn:hover:not(:disabled) {
  background: rgba(27, 73, 171, 1);
}

.show-solution-btn:active:not(:disabled) {
  background: rgba(27, 73, 171, 0.9);
}

.show-solution-btn:disabled {
  background: rgba(27, 73, 171, 0.4);
  cursor: not-allowed;
  opacity: 0.5;
}

/* Miniboard styling for dark mode */
.mini-chessboard {
  background: #2a2a2a !important;
}

.mini-chessboard .square.light {
  background: #3a3a3a !important;
}

.mini-chessboard .square.dark {
  background: #2a2a2a !important;
}

.mini-chessboard .square.move-from {
  background: #fffcdd !important;
}

.mini-chessboard .square.move-to {
  background: #fff79b !important;
}

.miniboard-link {
  text-decoration: none;
  color: inherit;
}

.position-name {
  margin-top: 5px;
  font-size: 12px;
  color: #ccc;
  text-align: center;
}

@media (max-width: 768px) {
  .recent-puzzle-item {
    flex-direction: column;
    align-items: flex-start;
  }
  
  .puzzle-actions {
    margin-top: 15px;
  }
}
</style>
